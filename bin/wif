#!/usr/bin/env python

from wif.io import *
import contextlib
import argparse
import tkinter as tk
from PIL import ImageTk
import sys
import re


@contextlib.contextmanager
def open_stdin():
    yield sys.stdin


@contextlib.contextmanager
def open_file(filename):
    with open(filename) as file:
        yield file


def open_input_stream(filename):
    if filename == 'STDIN':
        return open_stdin()
    else:
        return open_file(filename)


@contextlib.contextmanager
def open_output_stream(filename):
    if filename == 'STDOUT':
        yield sys.stdout.buffer
    else:
        with open(filename, 'wb') as file:
            yield file


def extract(args):
    def filename(index):
        return re.sub('%d', str(index).rjust(5, '0'), args.output)

    with open_input_stream(args.input) as stream:
        for index, block in enumerate(read_blocks(stream)):
            image = block_to_image(block)

            with open_output_stream(filename(index)) as out:
                image.save(out, format=args.format)


def info(args):
    with open_input_stream(args.input) as stream:
        sizes = []
        for index, block in enumerate(read_blocks(stream)):
            image = block_to_image(block)
            sizes.append((image.width, image.height))
            image.close()
        if len(set(sizes)) == 1:
            width = sizes[0][0]
            height = sizes[0][1]
            print(f"{len(sizes)} frames, each has size {width}x{height}")
        else:
            for index, size in enumerate(sizes):
                print(f"Frame {index} has size {size[0]}x{size[1]}")



class Application(tk.Frame):
    def __init__(self, root, frames):
        super().__init__(root)
        self.root = root
        self.__images = [ ImageTk.PhotoImage(frame) for frame in frames ]
        self.__index = 0
        self.pack()
        self.__create_widgets()
        self.__tick()

    def __create_widgets(self):
        self.__label = tk.Label(self)
        self.__label.pack()
        self.__update()

    def __update(self):
        image = self.__images[self.__index]
        self.__label.configure(image=image)
        self.__label.image = image

    def __tick(self):
        self.__index = (self.__index + 1) % len(self.__images)
        self.__update()
        self.root.after(1000 // 30, self.__tick)


def gui(args):
    with open_input_stream(args.input) as stream:
        frames = list(read_frames(stream))
        root = tk.Tk()
        app = Application(root, frames)
        app.mainloop()


parser = argparse.ArgumentParser(prog='wif')
subparsers = parser.add_subparsers(help='sub-command help')

subparser = subparsers.add_parser('extract', help='extract frames from the wif into separate files')
subparser.add_argument('--format', type=str, default='png')
subparser.add_argument('-i', '--input', type=str, default='STDIN')
subparser.add_argument('-o', '--output', type=str, default='frame%d.png')
subparser.set_defaults(func=extract)

subparser = subparsers.add_parser('info', help='prints information about the given WIF file')
subparser.add_argument('-i', '--input', type=str, default='STDIN')
subparser.set_defaults(func=info)

subparser = subparsers.add_parser('gui', help='opens GUI')
subparser.add_argument('-i', '--input', type=str, default='STDIN')
subparser.set_defaults(func=gui)

args = parser.parse_args()
args.func(args)
